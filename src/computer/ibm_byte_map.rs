pub fn map_ibm_byte_to_unicode(byte: u8) -> char {
    match byte {
        // Strap in, we need to match them all!
        // Yes, really, all 255 of them.
        // We can take some shortcuts, though -- you'll see!
        0x00 => 0x00.into(),
        0x01 => '☺',
        0x02 => '☻',
        0x03 => '♥',
        0x04 => '♦',
        0x05 => '♣',
        0x06 => '♠',
        0x07 => '•',
        0x08 => '◘',
        0x09 => '○',
        0x0a => '◙',
        0x0b => '♂',
        0x0c => '♀',
        0x0d => '♪',
        0x0e => '♫',
        0x0f => '☼',
        0x10 => '►',
        0x11 => '◄',
        0x12 => '↕',
        0x13 => '‼',
        0x14 => '¶',
        0x15 => '§',
        0x16 => '▬',
        0x17 => '↨',
        0x18 => '↑',
        0x19 => '↓',
        0x1a => '→',
        0x1b => '←',
        0x1c => '∟',
        0x1d => '↔',
        0x1e => '▲',
        0x1f => '▼',
        // Thank god, the next few are all ASCII.
        0x20..=0x7e => byte.into(),
        0x7f => '⌂',
        0x80 => 'Ç',
        0x81 => 'ü',
        0x82 => 'é',
        0x83 => 'â',
        0x84 => 'ä',
        0x85 => 'à',
        0x86 => 'å',
        0x87 => 'ç',
        0x88 => 'ê',
        0x89 => 'ë',
        0x8a => 'è',
        0x8b => 'ï',
        0x8c => 'î',
        0x8d => 'ì',
        0x8e => 'Ä',
        0x8f => 'Å',
        0x90 => 'É',
        0x91 => 'æ',
        0x92 => 'Æ',
        0x93 => 'ô',
        0x94 => 'ö',
        0x95 => 'ò',
        0x96 => 'û',
        0x97 => 'ù',
        0x98 => 'ÿ',
        0x99 => 'Ö',
        0x9a => 'Ü',
        0x9b => '¢',
        0x9c => '£',
        0x9d => '¥',
        0x9e => '₧',
        0x9f => 'ƒ',
        0xa0 => 'á',
        0xa1 => 'í',
        0xa2 => 'ó',
        0xa3 => 'ú',
        0xa4 => 'ñ',
        0xa5 => 'Ñ',
        0xa6 => 'ª',
        0xa7 => 'º',
        0xa8 => '¿',
        0xa9 => '⌐',
        0xaa => '¬',
        0xab => '½',
        0xac => '¼',
        0xad => '¡',
        0xae => '«',
        0xaf => '»',
        0xb0 => '░',
        0xb1 => '▒',
        0xb2 => '▓',
        0xb3 => '│',
        0xb4 => '┤',
        0xb5 => '╡',
        0xb6 => '╢',
        0xb7 => '╖',
        0xb8 => '╕',
        0xb9 => '╣',
        0xba => '║',
        0xbb => '╗',
        0xbc => '╝',
        0xbd => '╜',
        0xbe => '╛',
        0xbf => '┐',
        0xc0 => '└',
        0xc1 => '┴',
        0xc2 => '┬',
        0xc3 => '├',
        0xc4 => '─',
        0xc5 => '┼',
        0xc6 => '╞',
        0xc7 => '╟',
        0xc8 => '╚',
        0xc9 => '╔',
        0xca => '╩',
        0xcb => '╦',
        0xcc => '╠',
        0xcd => '═',
        0xce => '╬',
        0xcf => '╧',
        0xd0 => '╨',
        0xd1 => '╤',
        0xd2 => '╥',
        0xd3 => '╙',
        0xd4 => '╘',
        0xd5 => '╒',
        0xd6 => '╓',
        0xd7 => '╫',
        0xd8 => '╪',
        0xd9 => '┘',
        0xda => '┌',
        0xdb => '█',
        0xdc => '▄',
        0xdd => '▌',
        0xde => '▐',
        0xdf => '▀',
        0xe0 => 'ɑ',
        0xe1 => 'ϐ',
        0xe2 => 'ᴦ',
        0xe3 => 'ᴨ',
        0xe4 => '∑',
        0xe5 => 'ơ',
        0xe6 => 'µ',
        0xe7 => 'ᴛ',
        0xe8 => 'ɸ',
        0xe9 => 'ϴ',
        0xea => 'Ω',
        0xeb => 'ẟ',
        0xec => '∞',
        0xed => '∅',
        0xee => '∈',
        0xef => '∩',
        0xf0 => '≡',
        0xf1 => '±',
        0xf2 => '≥',
        0xf3 => '≤',
        0xf4 => '⌠',
        0xf5 => '⌡',
        0xf6 => '÷',
        0xf7 => '≈',
        0xf8 => '°',
        0xf9 => '∙',
        0xfa => '·',
        0xfb => '√',
        0xfc => 'ⁿ',
        0xfd => '²',
        0xfe => '■',
        0xff => ' ',
    }
}

pub fn map_unicode_to_ibm_byte(utf_8: char) -> u8 {
    match utf_8 {
        // Strap in, we need to match them all!
        // Yes, really, all 255 of them.
        // We can take some shortcuts, though -- you'll see!
        '\u{00}' => 0x00,
        '☺' => 0x01,
        '☻' => 0x02,
        '♥' => 0x03,
        '♦' => 0x04,
        '♣' => 0x05,
        '♠' => 0x06,
        '•' => 0x07,
        '◘' => 0x08,
        '○' => 0x09,
        '◙' => 0x0a,
        '♂' => 0x0b,
        '♀' => 0x0c,
        '♪' => 0x0d,
        '♫' => 0x0e,
        '☼' => 0x0f,
        '►' => 0x10,
        '◄' => 0x11,
        '↕' => 0x12,
        '‼' => 0x13,
        '¶' => 0x14,
        '§' => 0x15,
        '▬' => 0x16,
        '↨' => 0x17,
        '↑' => 0x18,
        '↓' => 0x19,
        '→' => 0x1a,
        '←' => 0x1b,
        '∟' => 0x1c,
        '↔' => 0x1d,
        '▲' => 0x1e,
        '▼' => 0x1f,
        // Thank god, the next few are all ASCII.
        ' '..='~' => {
            let mut buf = [0u8; 1];
            // This next line panics if it tries to encode a character
            // that can't be given as a single byte.
            // Because I'm slicing pure ASCII characters, it should never do that.
            // Should.
            utf_8.encode_utf8(&mut buf);

            buf[0]
        },
        '⌂' => 0x7f,
        'Ç' => 0x80,
        'ü' => 0x81,
        'é' => 0x82,
        'â' => 0x83,
        'ä' => 0x84,
        'à' => 0x85,
        'å' => 0x86,
        'ç' => 0x87,
        'ê' => 0x88,
        'ë' => 0x89,
        'è' => 0x8a,
        'ï' => 0x8b,
        'î' => 0x8c,
        'ì' => 0x8d,
        'Ä' => 0x8e,
        'Å' => 0x8f,
        'É' => 0x90,
        'æ' => 0x91,
        'Æ' => 0x92,
        'ô' => 0x93,
        'ö' => 0x94,
        'ò' => 0x95,
        'û' => 0x96,
        'ù' => 0x97,
        'ÿ' => 0x98,
        'Ö' => 0x99,
        'Ü' => 0x9a,
        '¢' => 0x9b,
        '£' => 0x9c,
        '¥' => 0x9d,
        '₧' => 0x9e,
        'ƒ' => 0x9f,
        'á' => 0xa0,
        'í' => 0xa1,
        'ó' => 0xa2,
        'ú' => 0xa3,
        'ñ' => 0xa4,
        'Ñ' => 0xa5,
        'ª' => 0xa6,
        'º' => 0xa7,
        '¿' => 0xa8,
        '⌐' => 0xa9,
        '¬' => 0xaa,
        '½' => 0xab,
        '¼' => 0xac,
        '¡' => 0xad,
        '«' => 0xae,
        '»' => 0xaf,
        '░' => 0xb0,
        '▒' => 0xb1,
        '▓' => 0xb2,
        '│' => 0xb3,
        '┤' => 0xb4,
        '╡' => 0xb5,
        '╢' => 0xb6,
        '╖' => 0xb7,
        '╕' => 0xb8,
        '╣' => 0xb9,
        '║' => 0xba,
        '╗' => 0xbb,
        '╝' => 0xbc,
        '╜' => 0xbd,
        '╛' => 0xbe,
        '┐' => 0xbf,
        '└' => 0xc0,
        '┴' => 0xc1,
        '┬' => 0xc2,
        '├' => 0xc3,
        '─' => 0xc4,
        '┼' => 0xc5,
        '╞' => 0xc6,
        '╟' => 0xc7,
        '╚' => 0xc8,
        '╔' => 0xc9,
        '╩' => 0xca,
        '╦' => 0xcb,
        '╠' => 0xcc,
        '═' => 0xcd,
        '╬' => 0xce,
        '╧' => 0xcf,
        '╨' => 0xd0,
        '╤' => 0xd1,
        '╥' => 0xd2,
        '╙' => 0xd3,
        '╘' => 0xd4,
        '╒' => 0xd5,
        '╓' => 0xd6,
        '╫' => 0xd7,
        '╪' => 0xd8,
        '┘' => 0xd9,
        '┌' => 0xda,
        '█' => 0xdb,
        '▄' => 0xdc,
        '▌' => 0xdd,
        '▐' => 0xde,
        '▀' => 0xdf,
        'ɑ' => 0xe0,
        'ϐ' => 0xe1,
        'ᴦ' => 0xe2,
        'ᴨ' => 0xe3,
        '∑' => 0xe4,
        'ơ' => 0xe5,
        'µ' => 0xe6,
        'ᴛ' => 0xe7,
        'ɸ' => 0xe8,
        'ϴ' => 0xe9,
        'Ω' => 0xea,
        'ẟ' => 0xeb,
        '∞' => 0xec,
        '∅' => 0xed,
        '∈' => 0xee,
        '∩' => 0xef,
        '≡' => 0xf0,
        '±' => 0xf1,
        '≥' => 0xf2,
        '≤' => 0xf3,
        '⌠' => 0xf4,
        '⌡' => 0xf5,
        '÷' => 0xf6,
        '≈' => 0xf7,
        '°' => 0xf8,
        '∙' => 0xf9,
        '·' => 0xfa,
        '√' => 0xfb,
        'ⁿ' => 0xfc,
        '²' => 0xfd,
        '■' => 0xfe,
        '\u{00a0}' => 0xff,
        _ => 0x3f,  // the '?' character
    }
}
